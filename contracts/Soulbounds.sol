// SPDX-License-Identifier: MIT

pragma solidity ^0.8.17;

import './Interfaces/ISoulbounds.sol';
import './Interfaces/IRegistry.sol';
import './Standards/ERC5633.sol';
import '@openzeppelin/contracts/utils/cryptography/ECDSA.sol';

contract Soulbounds is ISoulbounds, ERC5633 {
    using ECDSA for bytes32;

    mapping(uint => bool) private initialized;
    mapping(address => bool) private mintedSuper;

    address private controlAddress;
    address private registryAddress;
    IRegistry internal registry;

    modifier onlyControl() {
        _checkControlContract();
        _;
    }

    constructor(
        address _controlAddress,
        address _registryAddress,
        string memory _salesUri,
        string memory _rareUri,
        string memory _secretSuperUri
    ) ERC1155('') ERC5633() {
        controlAddress = _controlAddress;
        registryAddress = _registryAddress;
        registry = IRegistry(registryAddress);
        _setURI(0, _salesUri);
        _setURI(1, _rareUri);
        _setURI(2, _secretSuperUri);
        _setSoulbound(0, true);
        _setSoulbound(1, true);
        _setSoulbound(2, true);
        initialized[0] = true;
        initialized[1] = true;
        initialized[2] = true;
    }

    /*/////////////////////////////////////////////////////////////////// 
                                 MAIN FUNCTIONS
    ///////////////////////////////////////////////////////////////////*/

    /// @notice Mints the sales achievement NFT to the provided address, only callable by the marketplace contract
    /// @param _to - Address where the sales achievement NFT will be minted
    /// @dev Verifies that the caller is the marketplace contract
    /// @dev Mints the sales achievement NFT to the provided address with ID 0 and quantity 1
    /// @dev Emits an event to signal that the sales achievement NFT has been minted to the provided address

    function salesAchievement(address _to) external {
        require(
            _msgSender() == registry.getMarketplaceAddress(),
            'Soulbounds: Caller is not marketplace'
        );
        _mint(_to, 0, 1, '');
        emit SalesAchievementMinted(_to);
    }

    /// @notice Mint a rare achievement NFT to the specified address
    /// @dev Only the contract set as the random generator in the registry can call this function
    /// @param _to - Address to which the rare achievement NFT will be minted

    function rareAchievement(address _to) external {
        require(_msgSender() == registry.getRandomAddress(), 'Soulbounds: Callet is not random');
        _mint(_to, 1, 1, '');
        emit RareAchievementMinted(_to);
    }

    /// @notice Mints a super achievement NFT to the specified _to address, provided the caller has a valid signature and has not minted a super achievement before
    /// @param _to - The address that the NFT will be minted to
    /// @param _signature - A signature that verifies the caller's ownership of the address used to call the function
    /// @dev The signature is generated by the owner of the Registry contract and includes the caller's address as the message
    /// @dev The function checks if the caller has already minted a super achievement soulbound, and if not, checks if the signature is valid
    /// @dev If the checks pass, the function mints the soulbound to the specified address, sets the mintedSuper flag for the caller to true, and emits an event.

    function superAchievement(address _to, bytes calldata _signature) external {
        require(!mintedSuper[_msgSender()], 'Soulbounds: Super achievement available only once');
        require(
            isValidSignature(
                registry.getOwner(), // owner of registry contract
                keccak256(bytes(abi.encodePacked(_msgSender()))),
                _signature
            ),
            'Soulbounds: Signature not valid'
        );
        mintedSuper[_msgSender()] = true;
        _mint(_to, 2, 1, '');
        emit SuperAchievementMinted(_msgSender());
    }

    /// @notice Mints a specified amount of tokens to the specified address
    /// @param _to - The address that the tokens will be minted to
    /// @param _tokenId - The ID of the token to be minted
    /// @param _amount - The amount of tokens to be minted
    /// @dev The function can only be called by the control role contract, which restricts access to authorized parties
    /// @return A tuple containing the address that the tokens were minted to, the ID of the token minted, and the amount of tokens minted

    function mint(
        address _to,
        uint _tokenId,
        uint _amount
    ) external onlyControl returns (address, uint, uint) {
        _mint(_to, _tokenId, _amount, '');
        return (_to, _tokenId, _amount);
    }

    /*/////////////////////////////////////////////////////////////////// 
                                 SETTER FUNCTIONS
    ///////////////////////////////////////////////////////////////////*/

    /// @notice Sets the metadata URI and soulbound status for a specified token ID, only callable by the contract with control role
    /// @param _tokenId - The ID of the token to set metadata and soulbound status for
    /// @param _tokenUri - The URI for the token's metadata
    /// @param _soulbound - A boolean indicating whether the token is soulbound or not
    /// @dev Checks if the token has already been initialized, and if not, sets the URI and soulbound status for the specified token ID
    /// @return The token ID, URI, and soulbound status

    function setToken(
        uint _tokenId,
        string memory _tokenUri,
        bool _soulbound
    ) external onlyControl returns (uint, string memory, bool) {
        require(!initialized[_tokenId], 'Soulbounds: Already initialized');
        initialized[_tokenId] = true;
        _setURI(_tokenId, _tokenUri);
        _setSoulbound(_tokenId, _soulbound);
        return (_tokenId, _tokenUri, _soulbound);
    }

    /*/////////////////////////////////////////////////////////////////// 
                                 GETTER FUNCTIONS
    ///////////////////////////////////////////////////////////////////*/

    function isValidSignature(
        address signer,
        bytes32 msgHash,
        bytes calldata signature
    ) internal pure returns (bool) {
        return ECDSA.recover(ECDSA.toEthSignedMessageHash(msgHash), signature) == signer;
    }

    function _checkControlContract() internal view {
        require(_msgSender() == controlAddress, 'Soulbounds: Caller is not control contract');
    }
}
